# OS

## 进程的三个组成部分？

程序段、数据段、PCB(Process Control Block)

## 进程和线程

进程是对运行时程序的封装 (具有一定独立功能的程序关于某个数据集合上的一次运行活动), 是系统进行**资源调度和分配的基本单位**

线程是进程的一个实体, 是**CPU调度和分派的基本单位**, 只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)

系统开销, 线程是轻量级的进程

## 进程间通信

+ 管道
+ 信号 (signal)
+ 共享内存
+ 信号量
+ 套接字

## 死锁

两个或多个进程无限期的阻塞、相互等待的一种状态

+ 互斥 (资源不共享)
+ 占有并等待 (请求保持)
+ 非抢占 (不剥夺)
+ 循环等待

## 分页分段

- 目的不同：分页是由于**系统管理的需要**而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地**满足用户的需要**，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
- 大小不同：**页的大小固定且由系统决定**，而段的长度却不固定，取决于用户编写的程序；
- 地址空间不同： **段向用户提供二维地址空间**；**页向用户提供的是一维地址空间**；
- 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
- 内存碎片：页式存储管理的优点是没有**外碎片**（因为页的大小固定），但会产生**内碎片**（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

## cache的作用

**解决CPU与主存之间速度不匹配的问题**



## 同步机制

+ 信号量
+ 条件变量
+ 事件
+ 原子操作
+ 锁
+ 管程: 将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。

## 虚拟内存

虚拟内存允许执行进程不必完全在内存中。

每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。

这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。

当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的**映射**；当程序引用到一部分不在物理内存中的地址空间时，由**操作系统负责将缺失的部分装入物理内存并重新执行失败的命令** (缺页异常)。

这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。

好处

+ 在内存中可以保留多个进程，系统并发度提高
+ **更大的地址空间**, **保护和隔离**, **简化编程**

## 页面置换算法

+ FIFO
+ LRU: 最近最少用
+ 随机
+ LFU(最少使用), clock, NRU
+ OPT: 理论最优, 实际最晚使用

# 计网

## 三次握手

![image-20240601201904212](https://raw.githubusercontent.com/bsnmldb/tuchuang/main/img/202406012019085.png)

### 为什么两次不可以

为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。

　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。

## TCP与UDP的区别

TCP是**面向连接**的，UDP是无连接的；

TCP是**可靠**的，UDP是不可靠的；

 TCP是**面向字节流**的，UDP是面向报文的；

TCP有**拥塞控制**机制;UDP没有拥塞控制，适合媒体通信；

TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；

TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

## TCP的可靠性怎么实现

- 确认和超时重传
- 数据合理分片和排序
- 流量控制
- 拥塞控制
- 数据校验

## 从输入网址到获得页面的过程

1. DNS域名解析为ip
   1. DNS缓存
   2. 本地DNS
   3. 递归查询
2. 浏览器建立TCP连接 (三次握手)
3. HTTP请求



## TCP/IP协议模型

1. 应用层 (application): 存留网络应用程序和应用层协议,向**应用程序**提供网络服务传递报文
2. 运输层 (transport): 在**应用程序端点(端系统)之间**传送应用层报文
3. 网络层 (network): 将数据报从一台**主机**移动到另一台主机
4. 链路层 (link): 把信息组织为**帧**,将分组从一个**节点**移动到路径上的下一个节点
5. 物理层 (physical): 将帧的一个个**比特**从一个节点移动到下一个节点

## 路由选择协议

- RIP协议：路由信息协议，底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。
- OSPF协议：开放最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。

# C++

## 面向对象的特点

- 封装 封装**只公开某些对外接口，隐藏具体实现细节**。增加了一定的安全性，防止信息的泄露以及破坏。
- 继承 在现有类（基类、父类）上建立新类（派生类、子类）的处理过程称为继承。派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能。**代码复用**
- 多态 多态指在程序设计中存在同名不同方法的存在，主要通过子类对父类的覆盖来实现多态，设计原则之一就是要依赖于抽象，而不依赖于具体，增加灵活性。多态就是为了体现这一原则。

## 纯虚函数

基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做

**定义接口 interface**

## static

1. 函数体外部: 文件内可见
   1. 修饰变量
   2. 修饰函数
2. 函数体内部修饰变量: 局部静态变量
3. 类: 属于类而不属于实例 (实例共享)
   1. 成员函数
   2. 值

## inline与宏定义

inline只是建议

宏定义是简单的文本替换, 没有函数的类型检查和作用域控制, 容易引发意外的副作用, inline有检查

**安全性**：内联函数在语法和类型安全性上比宏更可靠，因为它保留了函数调用时的参数检查和类型匹配。

**性能**：内联函数由编译器决定是否展开，而宏定义是简单的文本替换，可能导致代码膨胀或者不必要的计算。

**适用场景**：内联函数适合用于简单且频繁调用的函数，而宏适合于复杂的代码替换和生成。

# ds & algorithm

过程 (英语)

复杂度 (具体哪些部分)

正确性

## kruskal



## prim



## dijkstra





# 数学

## 线性代数中特征值和特征向量的意义？

特征值和特征向量体现了矩阵的性质

当考虑矩阵是一个变换时, *体现了会在哪些方向上缩放的大小是多少

特别地, 当矩阵具有一组基特征向量时, 任意向量都可以由特征向量表示, 更能清晰地体现矩阵作为变换的作用

矩阵分解

当矩阵作为信息时, 如PCA中特征值体现了主要的成分, 如图谱理论中矩阵的*与图的性质有很大的关系