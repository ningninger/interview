# 算法

## 1. 抽象算法设计与分析

### 算法的规约

+ 输入：明确规定了算法接受的所有合法输入
+ 输出：明确规定了对于每一组合法额度输入，相应的输出值应该是什么



### 算法正确性的证明：数学归纳法

弱数学归纳法：用前一项推断出后一项

强数学归纳法：用前n项推断出后n项



### 抽象算法的性能指标

最坏情况时间复杂度分析

平均情况下时间复杂度分析





## 2. 算法中的数学

### 函数的渐进增长率

5种符号：A = 符号（B）

+ $O$ ：A < B
+ $o$ ：A << B
+ $\Omega$ ：A > B
+ $\omega$：A >> B
+ $\theta$： A = B



其中：这5种关系均满足传递性

大写字母均满足自反性，即cost函数比可以为1





### 分治递归

递归树 sum of row sums 

什么是master定理：计算分治递归式子，用来对代价函数为多项式项时的简便运算



## 3. 蛮力算法的设计

### 蛮力选择和排序问题

选择rank为k的元素

暴力遍历的时间复杂度为n^2^





选择排序：选择数组中最大的或者最小的放到数组合适的位置

+ 正确性证明：数学归纳法





插入排序：维护一个前面有序的数组，没要多排序一个元素的时候，当作要在前面排好序的数组中插入一个元素

+ 正确性证明：数学归纳法



冒泡法：从逆序对的角度考虑，消除程序中的逆序对，让最大的元素随着交换逐渐排到数组的后面

+ 该算法的正确性不明显
+ 正确性证明：保证[1, j]中j为最大的元素



## 4. 分治排序

快速排序

快速排序算法的时间复杂度收到partition的严重影响，如果partition的结果不均衡，算法的性能越差，如果每次都是均衡的，那么时间为`nlogn`（使用了master定理）

如果快速排序算法的每次都是极不平衡的，那么该算法的时间复杂度为`n^2`

证明该算法的平均时间复杂度为`nlogn`的方法太难了，先不考虑了

![img](https://img-blog.csdn.net/20140522105345437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb29oYWhhXzEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

合并排序

合并算法的正确性主要从merge方法出发就可以了，只要保证merge前是两个排好序的数组，merge后是一个排好序的数组





决策树是一颗2-tree

通过计算决策树的高度可以得知比较排序的最坏情况时间复杂度下界为`nlogn`





## 5.线性时间选择

pivot平均线性时间选择：

如果要选择阶为k的元素，只需要k-1个比它小的元素在它前面， 剩下的比它大的元素在它后面，那就可以满足这一条件

但是该算法和快速选择算法一样都比较依赖partition，如果partition的结果不太平衡，那么该算法的时间复杂度会变为`n^2`，当然在一般情况下，该算法的时间复杂度为`n`



median最坏情况时间选择：

将原本的数组分成4部分，然后分别按照这4部分来进行查找





## 6. 对数时间查找

经典这般查找

又叫做二分查找，时间复杂度为`log n`

二叉搜索树（和堆不一样哦）



红黑树：

+ 不考虑叶子节点，红色的节点不能连续出现，即没有任何一个红色父节点有红色子节点，

+ 根结点为黑色，并且所有的外部节点（指的是叶子节点）为黑色



## 7. 分治算法设计要素

逆序对计数

分成两个数组A（左边）和B（右边），

如果B的元素更小，那么其会与A数组中还没进行合并的元素组成逆序对了。



黄宇老师最喜欢的芯片检测

问题：有n片芯片，但是里面有好有坏，检测器可以让芯片相互报告对方的好坏，我们希望找出所有的好芯片（这个是个伪命题，真真正要做的就是只需要找到一个芯片的好坏就可以了）

+ 由对手论证可以证明弱超过一半的芯片是坏的，那么在这种情况下任何的算法都不能确保正确的判断每片芯片的好坏
+ 检测的四种结果

| A芯片 | B芯片 | 结论                 |
| ----- | ----- | -------------------- |
| B好   | A好   | 都是好的或者都是坏的 |
| B好   | A坏   | 至少一个是坏的       |
| B好   | A坏   | 至少一个是坏的       |
| B坏   | A坏   | 至少一个是坏的       |

+ 后三种全扔掉
+ 第一种挑一个放回来，这是在前一种做法完成后的做法，首先肯定在进行前是好的比坏的多，全是坏的对是k的话，那么好的对至少是k+1，这么做之后，好的也是比坏的多的



最后能找到一个好的，那么做法就是O（n）



w(n) = w(n/2) + O(n)





## 8.图算法

图的两种表示方式：邻接矩阵和邻接表

有向图的深度优先遍历

深度优先遍历树：有向图的深度优先遍历树存在TE、BE、DE、CE（cross edge，不同子树之间的边，所连接的边没有祖先关系）

有向图的深度优先遍历的的应用：

+ 拓扑排序：有向无环图当且仅当有拓扑排序，所以可以用拓扑排序来检查该图是否存在环
+ 关键路径
+ 有向图中的强连通片：如果一个有向图是强连通，那么它的两个节点一定是互相可达的，一个强连通图也可以视为是一个等价类。
+ 将有向图中的强连通图都合并，可以得到一个收缩图，收缩图必定是弱连通的，必定无环



无向图上的深度优先遍历：

必定没有CE

无向图的深度优先遍历的应用：

+ 寻找割点和割边：
  + 割点：该点为割点的判断依据是该点的自述没有任何BE指向该点的祖先，让自己遍历到的点作为自己的back时间
  + 桥：仅仅是等号有差别，割点有等号，桥无等号







## 9.图的广度优先遍历

不可能存在DE和CE

广度优先遍历的应用：

判断二分图：

使用广度有点遍历算法，对于一条边给予不同的颜色，如果边的两端的颜色相同



寻找k度子图：

将度数小于k的节点加入队列，从队列中取出，其相关的边剪去，如果出现了新的小于k的节点了，就将其加入到队列当中





## 10.图优化问题的贪心求解

最小生成树问题

算法：prim和kruskal

### prim（一种贪心算法）

从某一点出发，找与之相邻且没有被访问的点加入到生成树中

基于数组的优先队列： O（n^2 + m）

基于堆的优先队列： O（（m+n）logn）



对稠密图友好的





### Kruskal（一种贪心算法）

每次选择图中最短的边，如果这条边使得原来的最短路中出现一个环就可以

mlogm （n+m）logn



对稀疏图友好的



### MCE框架

如果存在一个切使得e成为该切的MCE，则e必然属于某一刻最小生成树



prim每次都选择了一个MCE，那么Prim所选择的所有mce一定是最小生成树



同理kruskal选择的每次都是一个mce





### Dijkstra算法

该算法会维护，原点到其他的节点的长度，当发现一条新的边的时候，就会根据其尝试发现新的节点，然后根据第三方点或者原点来判断是否能够到达该新节点

证明dijkstra的正确性：使用数学归纳法

对于第一个点选择的是最短路，假设k个点都是最短路径，那么对于k+1个点呢

反证，我们假设加入的点k+1不是最短路径，应该是u，那么就有`dist[k+1] > dist[u]`，但是我们每次都选择最短的的点，所以应该选择的就是u

为什么dijkstra算法无法作用于存在负权边的图

dijkstra不会因为存在负权边，而更新已经记录的最短路，这可能导致一定的问题，Dijkstra算法是通过当前离起点最近的点来更新其他的点的距离，这样可能会导致之前维护的最短路的信息是错误的，所以dijkstra无法作用于存在负权边的图

解决方法：

+ 换算法：使用bellman-ford算法、floyd算法、SPFA算法、A*算法



## 11. 贪心算法

哈夫曼编码：每次选择数组中的两个最小的捏在一起，放回数组中，数组元素总是该huffman编码的叶子节点





## 12. 图优化问题

有向无环图上的给定源点最短路径问题：

DAG-SSSP算法，使用拓扑序列来计算



所有点对的最短路径问题

Floyd-warshell算法

不能计算负权回路（这里的负权回路是指一个回路上所有变的权值加在一起为负数）



## 13. 动态规划

矩阵相乘

编辑距离

硬币兑换

相容任务调度



